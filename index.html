<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>React App</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="800" height="900"></canvas>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.141.0/build/three.module.js",
          "GLTFLoader": "https://unpkg.com/three@0.141.0/examples/jsm/loaders/GLTFLoader.js",
          "OrbitControls": "https://unpkg.com/three@0.141.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
    <script type="module">
      import { GLTFLoader } from "GLTFLoader";
      import * as THREE from "three";
      import { OrbitControls } from "OrbitControls";

      let scene = new THREE.Scene();
      let renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
      });

      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.outputEncoding = THREE.sRGBEncoding;

      let camera = new THREE.PerspectiveCamera(30, 1);
      camera.position.set(0, 2, 10); // 카메라 위치 설정

      // OrbitControls를 추가합니다.
      let controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // 부드러운 회전을 위한 damping 활성화
      controls.dampingFactor = 0.25;

      let loader = new GLTFLoader();
      loader.load("tree/scene.gltf", function (gltf) {
        let model = gltf.scene;
        scene.add(gltf.scene);
        scene.background = new THREE.Color("white");

        let ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // 색상과 강도
        scene.add(ambientLight);

        let dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(0, 5, 5); // 위치 설정
        scene.add(dirLight);

        const box = new THREE.Box3().setFromObject(model);
        const boxCenter = box.getCenter(new THREE.Vector3());
        const boxSize = box.getSize(new THREE.Vector3());

        model.position.sub(boxCenter);
        model.position.y += boxSize.y / 2;

        controls.target.copy(new THREE.Vector3(0, boxSize.y / 2, 0));
        controls.update();

        model.traverse((child) => {
          if (child.isMesh) {
            child.material.color.set(0x228b22);
          }
        });

        function animate() {
          requestAnimationFrame(animate);
          controls.update(); // OrbitControls 업데이트를 추가합니다.
          renderer.render(scene, camera);
        }
        animate();
      });

      window.addEventListener("resize", onWindowResize, false);

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // 카메라 이동 제한
      function limitCameraPosition() {
        const minCameraY = 1; // 카메라가 내려갈 수 있는 최소 높이
        const maxCameraY = 20; // 카메라가 올라갈 수 있는 최대 높이

        // 카메라의 위치를 제한합니다.
        camera.position.y = Math.min(
          Math.max(camera.position.y, minCameraY),
          maxCameraY
        );

        // 카메라의 시선이 나무 아래를 보지 못하게 합니다.
        const minTargetY = 1; // 타겟이 내려갈 수 있는 최소 높이
        const maxTargetY = 20; // 타겟이 올라갈 수 있는 최대 높이
        controls.target.y = Math.min(
          Math.max(controls.target.y, minTargetY),
          maxTargetY
        );
      }

      // 매 프레임마다 카메라 위치 제한 함수를 호출하여 제한합니다.
      function update() {
        requestAnimationFrame(update);
        limitCameraPosition();
      }
      update();
    </script>
  </body>
</html>
